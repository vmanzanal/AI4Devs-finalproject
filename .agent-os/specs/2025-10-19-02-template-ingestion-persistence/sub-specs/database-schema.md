# Database Schema

This is the database schema implementation for the spec detailed in @.agent-os/specs/2025-10-19-02-template-ingestion-persistence/spec.md

## Overview

The template ingestion feature utilizes the existing database schema defined in the `2025-10-19-01-database-template-fields` spec. No new tables are required, but this document clarifies how the ingestion process populates the three core tables: `pdf_templates`, `template_versions`, and `template_fields`.

## Existing Tables Used

### 1. Table: `pdf_templates`

**Purpose:** Stores top-level template metadata and file information.

**Populated Fields During Ingestion:**

| Column            | Value Source                          | Notes                                              |
| ----------------- | ------------------------------------- | -------------------------------------------------- |
| `id`              | Auto-generated (SERIAL PRIMARY KEY)   | Database generates                                 |
| `name`            | User input via API request            | From `TemplateIngestRequest.name`                  |
| `version`         | User input via API request            | From `TemplateIngestRequest.version`               |
| `file_path`       | Generated by TemplateService          | Absolute container path: `/app/uploads/{uuid}.pdf` |
| `file_size_bytes` | Calculated from uploaded file         | Length of file content in bytes                    |
| `field_count`     | Calculated from analysis              | `len(analyzed_fields)` from PDFAnalysisService     |
| `sepe_url`        | User input via API request (optional) | From `TemplateIngestRequest.sepe_url`              |
| `uploaded_by`     | Current authenticated user ID         | From `current_user.id`                             |
| `created_at`      | Auto-generated                        | Server default: `now()`                            |
| `updated_at`      | Auto-generated                        | Initially `NULL`, set on updates                   |

**Constraints:**

- `name` and `version` are required (NOT NULL)
- `file_path` must be unique per ingestion (enforced by UUID generation)
- `uploaded_by` foreign key to `users.id`

**Example Insert:**

```python
template = PDFTemplate(
    name="Solicitud de Prestación por Desempleo",
    version="2024-Q1",
    file_path="/app/uploads/a3f2c4b8-9e12-4d5a-b6c7-1234567890ab.pdf",
    file_size_bytes=245760,
    field_count=48,
    sepe_url="https://www.sepe.es/...",
    uploaded_by=user_id
)
db.add(template)
db.flush()  # Get template.id
```

### 2. Table: `template_versions`

**Purpose:** Tracks version history and PDF document metadata for each template.

**Populated Fields During Ingestion:**

| Column              | Value Source                        | Notes                                          |
| ------------------- | ----------------------------------- | ---------------------------------------------- |
| `id`                | Auto-generated (SERIAL PRIMARY KEY) | Database generates                             |
| `template_id`       | Foreign key from `pdf_templates.id` | After template insert                          |
| `version_number`    | User input via API request          | Same as `pdf_templates.version`                |
| `change_summary`    | Set to "Initial version"            | For first ingestion, describes initial state   |
| `is_current`        | Set to `True`                       | First version is always current                |
| `title`             | Extracted from PDF metadata         | Via PyPDF2 `/Title` field                      |
| `author`            | Extracted from PDF metadata         | Via PyPDF2 `/Author` field                     |
| `subject`           | Extracted from PDF metadata         | Via PyPDF2 `/Subject` field                    |
| `creation_date`     | Extracted from PDF metadata         | Via PyPDF2 `/CreationDate`, parsed to datetime |
| `modification_date` | Extracted from PDF metadata         | Via PyPDF2 `/ModDate`, parsed to datetime      |
| `page_count`        | From PDFAnalysisService             | `PDFAnalysisService.get_page_count()`          |
| `created_at`        | Auto-generated                      | Server default: `now()`                        |

**Constraints:**

- `template_id` foreign key to `pdf_templates.id` (NOT NULL)
- `version_number` required (NOT NULL)
- `page_count` required (NOT NULL, default: 0)
- Only one version per template can have `is_current = True` (application-level enforcement)

**Example Insert:**

```python
version = TemplateVersion(
    template_id=template.id,
    version_number="2024-Q1",
    change_summary="Initial version",
    is_current=True,
    title="Solicitud de Prestación por Desempleo",
    author="Servicio Público de Empleo Estatal",
    subject="Prestaciones por desempleo",
    creation_date=datetime(2024, 1, 15, 10, 30, 0),
    modification_date=datetime(2024, 1, 20, 14, 45, 0),
    page_count=3
)
db.add(version)
db.flush()  # Get version.id
```

### 3. Table: `template_fields`

**Purpose:** Stores individual AcroForm field data extracted from the PDF.

**Populated Fields During Ingestion:**

| Column             | Value Source                            | Notes                                                                    |
| ------------------ | --------------------------------------- | ------------------------------------------------------------------------ |
| `id`               | Auto-generated (SERIAL PRIMARY KEY)     | Database generates                                                       |
| `version_id`       | Foreign key from `template_versions.id` | After version insert                                                     |
| `field_id`         | From PDFAnalysisService                 | AcroForm field name (e.g., "A0101")                                      |
| `field_type`       | From PDFAnalysisService                 | Normalized type: text, checkbox, radiobutton, listbox                    |
| `raw_type`         | From PDFAnalysisService                 | Original PDF field type: /Tx, /Btn, /Ch                                  |
| `page_number`      | Calculated during analysis              | 1-indexed page number where field appears                                |
| `field_page_order` | Calculated during analysis              | Sequential order within the page (0-indexed)                             |
| `near_text`        | From PDFAnalysisService                 | Closest text found near the field                                        |
| `value_options`    | From PDFAnalysisService                 | JSON array of options for select/radio/checkbox fields                   |
| `position_data`    | Calculated from PDF coordinates         | JSON object: `{"x": float, "y": float, "width": float, "height": float}` |
| `created_at`       | Auto-generated                          | Server default: `now()`                                                  |

**Constraints:**

- `version_id` foreign key to `template_versions.id` (NOT NULL)
- `field_id`, `field_type`, `page_number`, `field_page_order` are required (NOT NULL)
- `value_options` and `position_data` stored as JSONB for PostgreSQL (supports efficient querying)

**Example Insert (Bulk):**

```python
fields = [
    TemplateField(
        version_id=version.id,
        field_id="A0101",
        field_type="text",
        raw_type="/Tx",
        page_number=1,
        field_page_order=0,
        near_text="hasta un máximo de",
        value_options=None,
        position_data={"x": 120.5, "y": 450.2, "width": 80.0, "height": 15.0}
    ),
    TemplateField(
        version_id=version.id,
        field_id="A0102",
        field_type="text",
        raw_type="/Tx",
        page_number=1,
        field_page_order=1,
        near_text="que suponen",
        value_options=None,
        position_data={"x": 250.3, "y": 450.2, "width": 100.0, "height": 15.0}
    ),
    TemplateField(
        version_id=version.id,
        field_id="B0201",
        field_type="radiobutton",
        raw_type="/Btn",
        page_number=2,
        field_page_order=0,
        near_text="Seleccione una opción:",
        value_options=["Sí", "No"],
        position_data={"x": 150.0, "y": 600.0, "width": 12.0, "height": 12.0}
    )
]
db.bulk_save_objects(fields)
```

## Data Flow During Ingestion

### Step-by-Step Population Process

```
1. File Upload & Storage
   ├─ Generate UUID filename
   ├─ Save to /app/uploads/
   ├─ Calculate SHA256 checksum
   └─ Get file_size_bytes

2. PDF Analysis
   ├─ PDFAnalysisService.analyze_pdf()
   │   ├─ Extract form fields with types
   │   ├─ Find nearby text for each field
   │   ├─ Determine page numbers
   │   ├─ Calculate field page order
   │   └─ Get value options for selection fields
   ├─ PDFAnalysisService.get_page_count()
   └─ Extract PDF metadata (title, author, dates)

3. Database Transaction (Atomic)
   ├─ INSERT INTO pdf_templates
   │   └─ Flush to get template.id
   ├─ INSERT INTO template_versions
   │   └─ Flush to get version.id
   ├─ BULK INSERT INTO template_fields
   │   └─ Insert all fields at once for performance
   └─ COMMIT (or ROLLBACK on error)

4. Post-Success
   └─ Return template ID and metadata to frontend
```

## Indexing Strategy

The existing database schema already includes appropriate indexes:

**Performance-Critical Indexes:**

- `pdf_templates(id)` - Primary key index
- `pdf_templates(name)` - For searching by name
- `pdf_templates(version)` - For version filtering
- `pdf_templates(created_at)` - For chronological sorting
- `template_versions(template_id)` - For joining with templates
- `template_versions(is_current)` - For finding current versions
- `template_fields(version_id)` - For joining with versions

**Additional Indexes (If Not Present):**

```sql
-- Composite index for efficient field lookups within a version
CREATE INDEX idx_template_fields_version_page
ON template_fields(version_id, page_number, field_page_order);

-- Index for searching fields by ID across versions
CREATE INDEX idx_template_fields_field_id
ON template_fields(field_id);
```

## Data Integrity Rules

### Referential Integrity

**Cascade Deletion:**

- Deleting a `PDFTemplate` cascades to delete all `TemplateVersion` records
- Deleting a `TemplateVersion` cascades to delete all `TemplateField` records
- This ensures no orphaned records remain in the database

**Foreign Key Constraints:**

```sql
ALTER TABLE template_versions
ADD CONSTRAINT fk_template_versions_template_id
FOREIGN KEY (template_id)
REFERENCES pdf_templates(id)
ON DELETE CASCADE;

ALTER TABLE template_fields
ADD CONSTRAINT fk_template_fields_version_id
FOREIGN KEY (version_id)
REFERENCES template_versions(id)
ON DELETE CASCADE;

ALTER TABLE pdf_templates
ADD CONSTRAINT fk_pdf_templates_uploaded_by
FOREIGN KEY (uploaded_by)
REFERENCES users(id)
ON DELETE SET NULL;
```

### Application-Level Constraints

1. **Unique Version Constraint:**

   - Only one `TemplateVersion` per `template_id` should have `is_current = True`
   - Enforced in application logic during ingestion
   - Future versions will set current version to `False` before creating new current version

2. **Field Count Consistency:**

   - `pdf_templates.field_count` should match the count of `template_fields` for the current version
   - Calculated during ingestion: `field_count = len(analyzed_fields)`
   - Used for quick validation without joining tables

3. **File Path Uniqueness:**

   - Each ingestion generates a unique UUID-based filename
   - Prevents file path collisions across different templates
   - Format: `/app/uploads/{uuid4()}.pdf`

4. **Page Number Validation:**
   - `template_fields.page_number` must be between 1 and `template_versions.page_count`
   - Validated during field data transformation

## Database Migration

**Migration Status:** No migration required.

The database schema was created in the previous spec (`2025-10-19-01-database-template-fields`) via Alembic migration. This spec only defines how the existing tables are populated during the ingestion process.

**Migration File Reference:**

- Migration: `backend/alembic/versions/fa338313b3a3_add_template_metadata_and_template_.py`
- Tables created: `template_versions`, `template_fields` (additional columns)
- Status: Already applied

## Data Validation Rules

### Backend Validation (SQLAlchemy Models)

**PDFTemplate Model:**

```python
# Already defined in app/models/template.py
- name: String(255), NOT NULL
- version: String(50), NOT NULL
- file_path: String(500), NOT NULL
- file_size_bytes: Integer, NOT NULL
- field_count: Integer, default=0
```

**TemplateVersion Model:**

```python
# Already defined in app/models/template.py
- template_id: Integer, FK, NOT NULL
- version_number: String(50), NOT NULL
- page_count: Integer, NOT NULL, default=0
- is_current: Boolean, default=False
```

**TemplateField Model:**

```python
# Already defined in app/models/template.py
- version_id: Integer, FK, NOT NULL
- field_id: String(255), NOT NULL
- field_type: String(50), NOT NULL
- page_number: Integer, NOT NULL
- field_page_order: Integer, NOT NULL
```

### Pydantic Validation (API Layer)

**TemplateIngestRequest:**

```python
class TemplateIngestRequest(BaseModel):
    name: str = Field(..., max_length=255, min_length=1)
    version: str = Field(..., max_length=50, min_length=1)
    sepe_url: Optional[str] = Field(None, max_length=1000)

    @validator('sepe_url')
    def validate_url(cls, v):
        if v and not v.startswith(('http://', 'https://')):
            raise ValueError('SEPE URL must be a valid HTTP(S) URL')
        return v
```

## Checksum Storage

**Purpose:** File integrity verification and duplicate detection.

**Implementation:**

```python
import hashlib

def calculate_checksum(file_content: bytes) -> str:
    """Calculate SHA256 checksum of file content."""
    return hashlib.sha256(file_content).hexdigest()
```

**Storage Location:** Currently, checksum is returned in the API response but not stored in `pdf_templates` table.

**Recommendation:** Add `checksum` column to `pdf_templates` table in a future migration:

```sql
ALTER TABLE pdf_templates
ADD COLUMN checksum VARCHAR(64) NULL;

CREATE INDEX idx_pdf_templates_checksum
ON pdf_templates(checksum);
```

**Benefits:**

- Detect duplicate file uploads (same PDF uploaded multiple times)
- Verify file integrity after storage
- Enable content-based deduplication

**Migration for Future Enhancement:**

```python
# Future Alembic migration
def upgrade():
    op.add_column('pdf_templates',
        sa.Column('checksum', sa.String(64), nullable=True)
    )
    op.create_index('idx_pdf_templates_checksum',
        'pdf_templates', ['checksum']
    )

def downgrade():
    op.drop_index('idx_pdf_templates_checksum')
    op.drop_column('pdf_templates', 'checksum')
```

## Error Handling & Rollback

### Transaction Rollback Scenarios

**Scenario 1: PDF Analysis Failure**

```python
try:
    # File saved successfully
    file_path = save_file(file)

    # Analysis fails (invalid PDF, no fields, etc.)
    fields = pdf_service.analyze_pdf(file_path)

except PDFProcessingError:
    # Rollback: Delete uploaded file
    if os.path.exists(file_path):
        os.remove(file_path)
    raise HTTPException(400, "PDF analysis failed")
```

**Scenario 2: Database Transaction Failure**

```python
try:
    # File saved, analysis complete
    template = PDFTemplate(...)
    db.add(template)
    db.flush()

    # Version insert fails (constraint violation, etc.)
    version = TemplateVersion(...)
    db.add(version)
    db.commit()

except SQLAlchemyError:
    # Rollback: Delete uploaded file + rollback DB
    db.rollback()
    if os.path.exists(file_path):
        os.remove(file_path)
    raise HTTPException(500, "Database error during ingestion")
```

**Scenario 3: Partial Field Insert Failure**

```python
try:
    # Template and version created
    fields = [TemplateField(...) for field in analyzed_fields]
    db.bulk_save_objects(fields)
    db.commit()

except SQLAlchemyError:
    # Automatic rollback (entire transaction)
    # Cascade delete removes template and version
    db.rollback()
    if os.path.exists(file_path):
        os.remove(file_path)
    raise HTTPException(500, "Failed to persist field data")
```

## Performance Considerations

### Bulk Insert Optimization

**Why Bulk Insert:**

- SEPE templates can have 50-200+ fields
- Individual INSERT statements would be slow (N queries)
- `bulk_save_objects()` performs 1 query for all fields

**Benchmark (Estimated):**

```
50 fields:
- Individual inserts: ~500ms (10ms per field)
- Bulk insert: ~50ms (1 query)
- Performance gain: 10x faster

200 fields:
- Individual inserts: ~2000ms (10ms per field)
- Bulk insert: ~100ms (1 query)
- Performance gain: 20x faster
```

**Implementation:**

```python
# Use bulk_save_objects for field insertion
fields = [
    TemplateField(version_id=version.id, **field_data)
    for field_data in analyzed_fields
]
db.bulk_save_objects(fields)
```

### JSONB Efficiency (PostgreSQL)

**Position Data Storage:**

```json
{
  "x": 120.5,
  "y": 450.2,
  "width": 80.0,
  "height": 15.0
}
```

**Benefits:**

- Native JSON querying: `WHERE position_data->>'x' > 100`
- Efficient indexing: `CREATE INDEX ON template_fields USING GIN (position_data)`
- Schema flexibility: Can add more position attributes without migration

**Query Example:**

```sql
-- Find fields in a specific region
SELECT field_id, field_type
FROM template_fields
WHERE version_id = 123
  AND (position_data->>'page_number')::int = 1
  AND (position_data->>'x')::float BETWEEN 100 AND 200;
```

## Summary

This ingestion process populates the existing database schema with complete template data:

1. **pdf_templates**: Stores top-level metadata, file path, and field count
2. **template_versions**: Stores version history with PDF metadata and page count
3. **template_fields**: Stores all extracted field data with position and ordering

The implementation ensures:

- ✅ Atomic transactions (all-or-nothing persistence)
- ✅ Referential integrity (cascading deletes)
- ✅ Performance optimization (bulk inserts)
- ✅ Data validation (Pydantic + SQLAlchemy)
- ✅ Error handling (rollback + file cleanup)
